#!/usr/bin/env python3
"""
AKRODLABS PyVEX Malware Analysis Examples
Advanced malware analysis using VEX Intermediate Representation

This script demonstrates advanced malware analysis techniques using PyVEX
for cross-architecture malware understanding and pattern detection.
"""

import pyvex
import archinfo
import binascii
from typing import List, Dict, Any, Tuple

class MalwareAnalyzer:
    """PyVEX-based malware analysis engine"""
    
    def __init__(self):
        self.architectures = {
            'x86': archinfo.ArchX86(),
            'x64': archinfo.ArchAMD64(),
            'arm32': archinfo.ArchARM(),
            'arm64': archinfo.ArchAArch64(),
            'mips32': archinfo.ArchMIPS32(),
            'mips64': archinfo.ArchMIPS64()
        }
        
    def analyze_instruction_sequence(self, code_bytes: bytes, arch_name: str, base_addr: int = 0x1000) -> Dict:
        """Analyze a sequence of instructions using PyVEX"""
        
        if arch_name not in self.architectures:
            raise ValueError(f"Unsupported architecture: {arch_name}")
        
        arch = self.architectures[arch_name]
        
        try:
            # Lift to VEX IR
            irsb = pyvex.lift(code_bytes, base_addr, arch)
            
            analysis = {
                'architecture': arch_name,
                'base_address': hex(base_addr),
                'code_bytes': code_bytes.hex(),
                'instruction_count': irsb.instructions,
                'statements': len(irsb.statements),
                'exits': len(irsb.next),
                'vex_ir': irsb.pp(),
                'patterns': self.detect_malware_patterns(irsb),
                'operations': self.extract_operations(irsb)
            }
            
            return analysis
            
        except Exception as e:
            return {'error': str(e), 'architecture': arch_name}
    
    def detect_malware_patterns(self, irsb) -> List[str]:
        """Detect common malware patterns in VEX IR"""
        
        patterns = []
        vex_str = irsb.pp()
        
        # XOR operations (common in encryption/obfuscation)
        if 'Xor' in vex_str:
            patterns.append("XOR_OPERATION")
        
        # Memory operations (potential code injection)
        if 'STORE' in vex_str or 'LOAD' in vex_str:
            patterns.append("MEMORY_MANIPULATION")
        
        # Conditional jumps (control flow obfuscation)
        if any(jump in vex_str for jump in ['Ijk_Boring', 'Ijk_Call', 'Ijk_Ret']):
            patterns.append("CONTROL_FLOW_TRANSFER")
        
        # Arithmetic operations (potential decryption)
        if any(op in vex_str for op in ['Add', 'Sub', 'Mul']):
            patterns.append("ARITHMETIC_OPERATIONS")
        
        # Shift operations (common in crypto)
        if any(shift in vex_str for shift in ['Shl', 'Shr', 'Sar']):
            patterns.append("SHIFT_OPERATIONS")
        
        return patterns
    
    def extract_operations(self, irsb) -> Dict:
        """Extract operation statistics from VEX IR"""
        
        operations = {
            'memory_loads': 0,
            'memory_stores': 0,
            'register_puts': 0,
            'register_gets': 0,
            'arithmetic_ops': 0,
            'logical_ops': 0,
            'constants': []
        }
        
        vex_str = irsb.pp()
        
        # Count different operation types
        operations['memory_loads'] = vex_str.count('LDle') + vex_str.count('LDbe')
        operations['memory_stores'] = vex_str.count('STle') + vex_str.count('STbe')
        operations['register_puts'] = vex_str.count('PUT(')
        operations['register_gets'] = vex_str.count('GET:')
        
        # Count arithmetic operations
        for op in ['Add', 'Sub', 'Mul', 'Div']:
            operations['arithmetic_ops'] += vex_str.count(op)
        
        # Count logical operations
        for op in ['And', 'Or', 'Xor', 'Not']:
            operations['logical_ops'] += vex_str.count(op)
        
        return operations

def analyze_xor_decryption_routines():
    """Analyze XOR decryption routines across different architectures"""
    
    print("=== XOR Decryption Routine Analysis ===\n")
    
    analyzer = MalwareAnalyzer()
    
    # XOR decryption patterns for different architectures
    xor_patterns = {
        'x86_xor_loop': {
            'bytes': bytes.fromhex('31c0 8a1c 3031 c288 1c30 4075 f6'),  # XOR loop pattern
            'arch': 'x86',
            'description': 'x86 XOR decryption loop'
        },
        'x64_xor_key': {
            'bytes': bytes.fromhex('4831d8'),  # xor rax, rbx
            'arch': 'x64', 
            'description': 'x64 XOR with key register'
        },
        'arm64_eor': {
            'bytes': bytes.fromhex('200001ca'),  # eor x0, x1, x1
            'arch': 'arm64',
            'description': 'ARM64 EOR (XOR) operation'
        },
        'arm32_eor': {
            'bytes': bytes.fromhex('010030e0'),  # eor r0, r0, r1  
            'arch': 'arm32',
            'description': 'ARM32 EOR operation'
        }
    }
    
    for pattern_name, info in xor_patterns.items():
        print(f"Pattern: {pattern_name}")
        print(f"Description: {info['description']}")
        print(f"Architecture: {info['arch']}")
        
        analysis = analyzer.analyze_instruction_sequence(
            info['bytes'], 
            info['arch']
        )
        
        if 'error' not in analysis:
            print(f"Detected patterns: {', '.join(analysis['patterns'])}")
            print(f"Operations: {analysis['operations']}")
            print(f"VEX IR:\n{analysis['vex_ir']}")
        else:
            print(f"Analysis error: {analysis['error']}")
        
        print("-" * 60)

def analyze_control_flow_obfuscation():
    """Analyze control flow obfuscation techniques"""
    
    print("\n=== Control Flow Obfuscation Analysis ===\n")
    
    analyzer = MalwareAnalyzer()
    
    # Control flow patterns
    cf_patterns = {
        'x86_call_ret': {
            'bytes': bytes.fromhex('e800000000c3'),  # call +0; ret
            'arch': 'x86',
            'description': 'Call/Return obfuscation'
        },
        'x64_jmp_indirect': {
            'bytes': bytes.fromhex('ff2000000000'),  # jmp [rip+offset]
            'arch': 'x64',
            'description': 'Indirect jump obfuscation'
        },
        'arm64_branch_link': {
            'bytes': bytes.fromhex('00000094'),  # bl +0
            'arch': 'arm64', 
            'description': 'Branch with link'
        },
        'mips_jump_delay': {
            'bytes': bytes.fromhex('0800000000000000'),  # j +0; nop
            'arch': 'mips32',
            'description': 'Jump with delay slot'
        }
    }
    
    for pattern_name, info in cf_patterns.items():
        print(f"Control Flow Pattern: {pattern_name}")
        print(f"Description: {info['description']}")
        
        analysis = analyzer.analyze_instruction_sequence(
            info['bytes'],
            info['arch']
        )
        
        if 'error' not in analysis:
            print(f"Statements: {analysis['statements']}")
            print(f"Exits: {analysis['exits']}")
            print(f"Patterns: {', '.join(analysis['patterns'])}")
            print(f"VEX IR (truncated):")
            # Print first few lines of VEX IR
            vex_lines = analysis['vex_ir'].split('\n')[:5]
            for line in vex_lines:
                print(f"  {line}")
        else:
            print(f"Error: {analysis['error']}")
        
        print("-" * 50)

def analyze_shellcode_patterns():
    """Analyze common shellcode patterns across architectures"""
    
    print("\n=== Shellcode Pattern Analysis ===\n")
    
    analyzer = MalwareAnalyzer()
    
    # Common shellcode patterns
    shellcode_patterns = {
        'x86_getpc': {
            'bytes': bytes.fromhex('e800000000585d'),  # call $+5; pop eax; pop ebp
            'arch': 'x86',
            'description': 'x86 Get PC technique'
        },
        'x64_syscall': {
            'bytes': bytes.fromhex('0f05'),  # syscall
            'arch': 'x64',
            'description': 'x64 system call'
        },
        'arm64_svc': {
            'bytes': bytes.fromhex('010000d4'),  # svc #0
            'arch': 'arm64',
            'description': 'ARM64 supervisor call'
        },
        'arm32_swi': {
            'bytes': bytes.fromhex('000000ef'),  # swi #0
            'arch': 'arm32', 
            'description': 'ARM32 software interrupt'
        }
    }
    
    for pattern_name, info in shellcode_patterns.items():
        print(f"Shellcode: {pattern_name}")
        print(f"Description: {info['description']}")
        
        analysis = analyzer.analyze_instruction_sequence(
            info['bytes'],
            info['arch']
        )
        
        if 'error' not in analysis:
            print(f"Instructions: {analysis['instruction_count']}")
            print(f"Malware patterns: {', '.join(analysis['patterns'])}")
            
            # Check for system call indicators
            if 'syscall' in analysis['vex_ir'].lower() or 'swi' in analysis['vex_ir'].lower():
                print("⚠️  SYSTEM CALL DETECTED")
            
            print(f"Operations summary: {analysis['operations']}")
        else:
            print(f"Error: {analysis['error']}")
        
        print("-" * 50)

def compare_crypto_implementations():
    """Compare cryptographic implementations across architectures"""
    
    print("\n=== Cryptographic Implementation Comparison ===\n")
    
    analyzer = MalwareAnalyzer()
    
    # Simple ROT13/Caesar cipher implementations
    crypto_patterns = {
        'x86_rot13': {
            'bytes': bytes.fromhex('80c00d'),  # add al, 0xd (ROT13)
            'arch': 'x86',
            'description': 'x86 ROT13 character transformation'
        },
        'x64_xor_key': {
            'bytes': bytes.fromhex('48354d000000'),  # xor rax, 0x4d
            'arch': 'x64',
            'description': 'x64 XOR with immediate key'
        },
        'arm64_add_crypto': {
            'bytes': bytes.fromhex('200d0091'),  # add x0, x1, #0xd
            'arch': 'arm64',
            'description': 'ARM64 addition-based cipher'
        }
    }
    
    for pattern_name, info in crypto_patterns.items():
        print(f"Crypto Pattern: {pattern_name}")
        print(f"Description: {info['description']}")
        
        analysis = analyzer.analyze_instruction_sequence(
            info['bytes'],
            info['arch']
        )
        
        if 'error' not in analysis:
            operations = analysis['operations']
            
            print(f"Arithmetic operations: {operations['arithmetic_ops']}")
            print(f"Logical operations: {operations['logical_ops']}")
            
            # Identify crypto indicators
            indicators = []
            if operations['arithmetic_ops'] > 0:
                indicators.append("ARITHMETIC_CIPHER")
            if operations['logical_ops'] > 0:
                indicators.append("LOGICAL_CIPHER")
            if 'XOR_OPERATION' in analysis['patterns']:
                indicators.append("XOR_CIPHER")
            
            print(f"Crypto indicators: {', '.join(indicators) if indicators else 'None'}")
            
        else:
            print(f"Error: {analysis['error']}")
        
        print("-" * 50)

def malware_family_comparison():
    """Compare malware families using PyVEX analysis"""
    
    print("\n=== Malware Family Comparison ===\n")
    
    analyzer = MalwareAnalyzer()
    
    # Simulate different malware family characteristics
    families = {
        'family_a_x86': {
            'bytes': bytes.fromhex('31c040eb02cd20'),  # xor eax,eax; inc eax; jmp +2; int 0x20
            'arch': 'x86',
            'family': 'Family A (Packer)'
        },
        'family_a_x64': {
            'bytes': bytes.fromhex('4831c048ffc0'),  # xor rax,rax; inc rax
            'arch': 'x64', 
            'family': 'Family A (Packer) - x64 variant'
        },
        'family_b_arm': {
            'bytes': bytes.fromhex('0020a0e3010080e2'),  # mov r2, #0; add r0, r0, #1
            'arch': 'arm32',
            'family': 'Family B (Mobile Trojan)'
        }
    }
    
    print("Comparing malware families across architectures:\n")
    
    family_analysis = {}
    
    for sample_name, info in families.items():
        analysis = analyzer.analyze_instruction_sequence(
            info['bytes'],
            info['arch']
        )
        
        if 'error' not in analysis:
            family_analysis[sample_name] = {
                'family': info['family'],
                'arch': info['arch'],
                'patterns': analysis['patterns'],
                'operations': analysis['operations'],
                'complexity': analysis['statements']
            }
            
            print(f"Sample: {sample_name}")
            print(f"Family: {info['family']}")
            print(f"Architecture: {info['arch']}")
            print(f"Complexity (statements): {analysis['statements']}")
            print(f"Patterns: {', '.join(analysis['patterns'])}")
            print()
    
    # Find similarities between families
    print("Family Similarities:")
    print("-" * 30)
    
    for name1, data1 in family_analysis.items():
        for name2, data2 in family_analysis.items():
            if name1 < name2:  # Avoid duplicate comparisons
                common_patterns = set(data1['patterns']) & set(data2['patterns'])
                if common_patterns:
                    print(f"{name1} & {name2}: {', '.join(common_patterns)}")

def demonstrate_ir_lifting():
    """Demonstrate VEX IR lifting for malware analysis"""
    
    print("\n=== VEX IR Lifting Demonstration ===\n")
    
    # Example malware instruction sequences
    samples = [
        {
            'name': 'API Hash Resolution',
            'x86_bytes': bytes.fromhex('8b4424048b0031c08a140140c1c00d01c275f8c3'),
            'description': 'Common API hashing routine'
        },
        {
            'name': 'String Decryption',
            'x86_bytes': bytes.fromhex('ac3004aae2fb'),
            'description': 'Simple string decryption loop'
        }
    ]
    
    analyzer = MalwareAnalyzer()
    
    for sample in samples:
        print(f"Sample: {sample['name']}")
        print(f"Description: {sample['description']}")
        print(f"Bytes: {sample['x86_bytes'].hex()}")
        
        # Analyze with x86
        analysis = analyzer.analyze_instruction_sequence(
            sample['x86_bytes'],
            'x86'
        )
        
        if 'error' not in analysis:
            print(f"Instructions: {analysis['instruction_count']}")
            print(f"VEX Statements: {analysis['statements']}")
            print(f"Detected Patterns:")
            for pattern in analysis['patterns']:
                print(f"  - {pattern}")
            
            print(f"VEX IR (first 10 lines):")
            vex_lines = analysis['vex_ir'].split('\n')[:10]
            for line in vex_lines:
                if line.strip():
                    print(f"  {line}")
        
        print("-" * 60)

def main():
    """Main function demonstrating PyVEX malware analysis"""
    
    print("AKRODLABS PyVEX Malware Analysis Tool")
    print("=" * 50)
    
    try:
        # Run analysis demonstrations
        analyze_xor_decryption_routines()
        analyze_control_flow_obfuscation()
        analyze_shellcode_patterns()
        compare_crypto_implementations()
        malware_family_comparison()
        demonstrate_ir_lifting()
        
        print("\n" + "=" * 50)
        print("Analysis completed successfully!")
        print("Use these techniques to analyze unknown malware samples")
        
    except ImportError as e:
        print(f"Error: Missing required libraries - {e}")
        print("Install with: pip install pyvex archinfo")
    except Exception as e:
        print(f"Analysis error: {e}")

if __name__ == "__main__":
    main()
